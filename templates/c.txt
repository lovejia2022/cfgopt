/*
Generated by cfgopt, DO NOT EDIT.

This is both header and source file. Define CFGOPT_IMPL before include
this header file makes this a source file.
*/

#ifndef CFGOPT_{{name}}_H_
#define CFGOPT_{{name}}_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

enum cfgopt_result_type {
    CFGOPT_OK = 0,
    CFGOPT_UNDEFINED_FLAG,
    CFGOPT_MISSING_VALUE,
    CFGOPT_SYNTAX_ERROR,
};

// Undefined flag `name`.
struct cfgopt_undefined_flag {
    char const *name;
};

// Misssing value for flag `name`.
struct cfgopt_missing_value {
    char const *name;
};

// Can't parse `text` as `type`.
struct cfgopt_syntax_error {
    char const *type;
    char const *text;
};

struct cfgopt_result {
    enum cfgopt_result_type type;
    union {
        struct cfgopt_undefined_flag undefined_flag;
        struct cfgopt_missing_value missing_value;
        struct cfgopt_syntax_error syntax_error;
    } payload;
};

void cfgopt_print_result(struct cfgopt_result *r, FILE *file)
#ifndef CFGOPT_IMPL
    ;
#else
{
    switch (r->type) {
    case CFGOPT_OK:
        fprintf(file, "Ok");
        break;
    case CFGOPT_UNDEFINED_FLAG:
        fprintf(file, "Undefined flag: %s", r->payload.undefined_flag.name);
        break;
    case CFGOPT_MISSING_VALUE:
        fprintf(file,
            "Flag ``%s'' need a value, use ``-FLAG=VALUE'' or ``-FLAG VALUE''",
            r->payload.missing_value.name);
        break;
    case CFGOPT_SYNTAX_ERROR:
        fprintf(file, "Can't parse ``%s'' as %s",
            r->payload.syntax_error.text,
            r->payload.syntax_error.type
        );
        break;
    }
}
#endif /* CFGOPT_IMPL */

struct cfgopt_{{name}} {
    {%- for flag in flags %}
    {{ flag.type.c_type() }} cfg_{{flag.name}};
    {%- endfor %}
};

#ifndef CFGOPT_FATAL_EXIT
#define CFGOPT_FATAL_EXIT 1
#endif // CFGOPT_FATAL_EXIT

static inline void cfgopt_fatal(char const *message) {
    fprintf(stderr, "cfgopt: %s\n", message);
    exit(CFGOPT_FATAL_EXIT);
}

void cfgopt_{{name}}_init(struct cfgopt_{{name}} * cfg)
#ifndef CFGOPT_IMPL
    ;
#else
{
    {%- for flag in flags %}
    cfg->cfg_{{flag.name}} = {{flag.type.c_default()}};
    {%- endfor %}
}
#endif // CFGOPT_IMPL

#ifdef CFGOPT_IMPL
static struct cfgopt_result
cfgopt_parse_string(char const *arg, char const **out) {
    struct cfgopt_result r;
    *out = arg;
    r.type = CFGOPT_OK;
    return r;
}

static struct cfgopt_result
cfgopt_parse_int64(char const *arg, int64_t *out) {
    struct cfgopt_result r;
    *out = strtoll(arg, NULL, 10);
    r.type = CFGOPT_OK;
    return r;
}

static struct cfgopt_result
cfgopt_parse_float64(char const *arg, double *out) {
    struct cfgopt_result r;
    *out = strtod(arg, NULL);
    r.type = CFGOPT_OK;
    return r;
}

static struct cfgopt_result
cfgopt_parse_boolean(char const *arg, bool *out) {
    struct cfgopt_result r;

    if (strcmp(arg, "true") == 0) {
        *out = true;
        goto ok;
    }

    if (strcmp(arg, "false") == 0) {
        *out = true;
        goto ok;
    }

    r.type = CFGOPT_SYNTAX_ERROR;
    r.payload.syntax_error.type = "boolean";
    r.payload.syntax_error.text = arg;
    return r;
ok:
    r.type = CFGOPT_OK;
    return r;
}

enum flag_type {
    FLAG_int64,
    FLAG_boolean,
    FLAG_float64,
    FLAG_string,
};

struct flag_info {
    char const *name;
    int len;

    enum flag_type type;
    void *value;
};

static int FLAG_COUNT = {{flags.len()}};

#define logf(...)
#if 0
#define logf(...) \
    do { \
        fprintf(stderr, "# "); \
        fprintf(stderr, __VA_ARGS__); \
        fprintf(stderr, "\n"); \
        fflush(stderr); \
    } while (0)
#endif

#endif // CFGOPT_IMPL

struct cfgopt_result
cfgopt_{{name}}_parse(
    struct cfgopt_{{name}} * cfg,
    int argc,
    char const **argv)
#ifndef CFGOPT_IMPL
    ;
#else
{
    struct cfgopt_result r;

    struct flag_info flag_infos[] = {
        {%- for flag in flags %}
        {.name = "{{flag.name}}",
         .len = {{flag.name.len()}},
         .type = FLAG_{{flag.type.name()}},
         .value = &cfg->cfg_{{flag.name}}},
    	{%- endfor %}
    };

    int argi;

    for (argi = 0; argi < argc; ++argi) {
        char const *arg = argv[argi];

        if (arg[0] != '-') {
            // TODO: handle positional argument
            continue;
        }

        if (arg[1] == '-' && arg[2] == '\0') {
            // TODO: handle rest positional argument
            break;
        }

        logf("parse: %s", arg);

        char const *flag_value = NULL;
        enum flag_type flag_type;
        char const *name;
        int flagi;

        for (flagi = 0; flagi < FLAG_COUNT; ++flagi) {
            int len = flag_infos[flagi].len;
            name = flag_infos[flagi].name;
            flag_type = flag_infos[flagi].type;

            logf("try %s", name);

            if (strncmp(arg + 1, name, len) == 0) {
                if (arg[1 + len] == '=') {
                    flag_value = arg + 2 + len;
                } else if (arg[1 + len] == '\0') {
                    if (flag_type == FLAG_boolean) {
                        flag_value = "true";
                    } else {
                        r.type = CFGOPT_MISSING_VALUE;
                        r.payload.missing_value.name = argv[argi];
                        return r;
                    }
                }
            }

            if (flag_value != NULL) {
                break;
            }
        }

        if (flag_value == NULL) {
            r.type = CFGOPT_UNDEFINED_FLAG;
            r.payload.undefined_flag.name = argv[argi];
            return r;
        }

        logf("flag %s = %s", name, flag_value);

        void *flag_value_out = flag_infos[flagi].value;

        switch (flag_type) {
        case FLAG_int64:
            cfgopt_parse_int64(
                flag_value,
                (int64_t *)flag_value_out
            );
            break;
        case FLAG_boolean:
            cfgopt_parse_boolean(
                flag_value,
                (bool *)flag_value_out
            );
            break;
        case FLAG_float64:
            cfgopt_parse_float64(
                flag_value,
                (double *)flag_value_out
            );
            break;
        case FLAG_string:
            cfgopt_parse_string(
                flag_value,
                (char const **)flag_value_out
            );
            break;
        }
    }

    r.type = CFGOPT_OK;
    return r;
}
#endif // CFGOPT_IMPL

#endif // CFGOPT_{{name}}_H_
